name: Complete Basic CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}   # pourra contenir des majuscules / underscores

jobs:

  secret_scan:
    name: TruffleHog Secret Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - name: Run TruffleHog to find secrets
        uses: trufflesecurity/trufflehog@main
        with: { path: ./ }

  secret-scaning:
    name: secret scanning with gitleaks
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - uses: gitleaks/gitleaks-action@v2
        with:
          exit-code: 0
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  sast-scan:
    name: Semgrep SAST Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    container:
      image: semgrep/semgrep
    if: (github.actor != 'dependabot[bot]')
    steps:
      - uses: actions/checkout@v4
      - name: Run Semgrep Scan
        run: semgrep scan --config auto --sarif --output semgrep.sarif || true
      - name: Upload Semgrep SARIF to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        with: { sarif_file: semgrep.sarif }

  SCA-scan:
    name: Run OSV Scanner for SCA
    uses: "google/osv-scanner-action/.github/workflows/osv-scanner-reusable.yml@v2.2.2"
    permissions:
      actions: read
      security-events: write
      contents: read
    with:
      scan-args: |-
        --recursive
        ./
      upload-sarif: true
      fail-on-vuln: false

  # 1Ô∏è‚É£ JOB BUILD - Construction de l'image Docker (avec nom normalis√©)
  build-image:
    name: BUILD - Docker Image Construction
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      actions: read

    # Outputs pour les jobs suivants et SLSA
    outputs:
      image_name: ${{ steps.normalize.outputs.image_fqn }}
      digest: ${{ steps.build.outputs.digest }}
      image_uri: ${{ steps.normalize.outputs.image_fqn }}@${{ steps.build.outputs.digest }}
      tags: ${{ steps.meta.outputs.tags }}
      tags_json: ${{ steps.meta.outputs.json }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # üîß Normaliser le nom d'image (tout minuscule, remplace caract√®res non valides et '_' -> '-')
      - name: Normalize image name
        id: normalize
        run: |
          raw="${{ env.IMAGE_NAME }}"        # ex: Owner/Repo (peut contenir Maj/underscore)
          # autoris√©s: a-z 0-9 . _ - et '/'
          norm="$(echo "$raw" \
            | tr '[:upper:]' '[:lower:]' \
            | sed -E 's/[^a-z0-9._\/-]/-/g' \
            | sed -E 's/_/-/g')"
          echo "image_repo=$norm" >> $GITHUB_OUTPUT
          echo "image_fqn=${{ env.REGISTRY }}/$norm" >> $GITHUB_OUTPUT
          echo "Using image: ${{ env.REGISTRY }}/$norm"

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.normalize.outputs.image_fqn }}
          tags: |
            type=sha,prefix={{branch}}-,format=long,priority=1000
            type=sha,prefix={{branch}}-,format=short,priority=900
            type=ref,event=branch,priority=600
            type=ref,event=pr,priority=600
            type=raw,value=latest,enable={{is_default_branch}},priority=200
          labels: |
            org.opencontainers.image.title=${{ github.repository }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created={{date 'YYYY-MM-DDTHH:mm:ssZ'}}
            org.opencontainers.image.visibility=private

      - name: Build Docker image locally
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          load: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      # üíæ Sauvegarde + SBOM simple (scan du fichier)
      - name: Save Docker image as artifact
        run: |
          FIRST_TAG=$(echo '${{ steps.meta.outputs.tags }}' | cut -d',' -f1)
          echo "Saving $FIRST_TAG"
          docker save "$FIRST_TAG" | gzip > docker-image.tar.gz
          ls -lh docker-image.tar.gz

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ github.run_id }}
          path: docker-image.tar.gz
          retention-days: 1

      - name: Generate SBOM (from archive)
        uses: anchore/sbom-action@v0
        with:
          file: docker-image.tar.gz
          format: spdx-json
          artifact-name: sbom-${{ github.run_id }}.spdx.json

      - name: Display build information
        run: |
          echo "Image FQN: ${{ steps.normalize.outputs.image_fqn }}"
          echo "Temp digest: ${{ steps.build.outputs.digest }}"
          echo "Tags:"
          echo "${{ steps.meta.outputs.tags }}" | tr ',' '\n' | sed 's/^/  - /'

  # 2Ô∏è‚É£ JOB SCAN - Scanner de s√©curit√© des containers
  container-scan:
    name: "üîç SCAN - Container Security Analysis"
    runs-on: ubuntu-latest
    needs: build-image
    permissions:
      contents: read
      security-events: write
      actions: read
    outputs:
      scan_status: ${{ steps.scan-status.outputs.status }}
      critical_count: ${{ steps.scan-status.outputs.critical }}
      high_count: ${{ steps.scan-status.outputs.high }}
    steps:
      - uses: actions/checkout@v4
      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:  
          name: docker-image-${{ github.run_id }}
      - name: Load Docker image
        run: |
          docker load < docker-image.tar.gz
          docker images
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ fromJSON(needs.build-image.outputs.tags_json).tags[0] }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          exit-code: 0
          severity: 'CRITICAL,HIGH'
        continue-on-error: true
      - name: Upload Trivy scan results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with: { sarif_file: trivy-results.sarif }
        continue-on-error: true
      - name: Analyze scan results
        id: scan-status
        run: |
          if [ -f trivy-results.sarif ]; then
            CRITICAL_COUNT=$(jq '[.runs[0].results[] | select(.level == "error")] | length' trivy-results.sarif 2>/dev/null || echo "0")
            HIGH_COUNT=$(jq '[.runs[0].results[] | select(.level == "warning")] | length' trivy-results.sarif 2>/dev/null || echo "0")
            echo "critical=$CRITICAL_COUNT" >> $GITHUB_OUTPUT
            echo "high=$HIGH_COUNT" >> $GITHUB_OUTPUT
            if [ "$CRITICAL_COUNT" -gt "0" ]; then
              echo "status=critical_found" >> $GITHUB_OUTPUT
            else
              echo "status=safe" >> $GITHUB_OUTPUT
            fi
          else
            echo "status=scan_failed" >> $GITHUB_OUTPUT
          fi

  # 3Ô∏è‚É£ JOB PUSH - Publication de l'image Docker
  push-image:
    name: "üöÄ PUSH - Docker Image Publication"
    runs-on: ubuntu-latest
    needs: [build-image, container-scan]
    permissions:
      contents: read
      packages: write
      actions: read
    outputs:
      image_name: ${{ needs.build-image.outputs.image_name }}
      digest: ${{ steps.push.outputs.digest }}
      image_uri: ${{ needs.build-image.outputs.image_name }}@${{ steps.push.outputs.digest }}
      tags: ${{ needs.build-image.outputs.tags }}
    steps:
      - uses: actions/checkout@v4
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata (for push)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.build-image.outputs.image_name }}     # ‚¨ÖÔ∏è nom normalis√©
          tags: |
            type=sha,prefix={{branch}}-,format=long,priority=1000
            type=sha,prefix={{branch}}-,format=short,priority=900
            type=ref,event=branch,priority=600
            type=ref,event=pr,priority=600
            type=raw,value=latest,enable={{is_default_branch}},priority=200
          labels: |
            org.opencontainers.image.title=${{ github.repository }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created={{date 'YYYY-MM-DDTHH:mm:ssZ'}}
            org.opencontainers.image.visibility=private
      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      - name: Display complete build information
        run: |
          echo "Image FQN: ${{ needs.build-image.outputs.image_name }}"
          echo "FINAL digest: ${{ steps.push.outputs.digest }}"
          echo "URI: ${{ needs.build-image.outputs.image_name }}@${{ steps.push.outputs.digest }}"

  # 4Ô∏è‚É£ JOB SLSA - Attestation + V√©rification (utilise le nom normalis√©)
  attest:
    name: "üîè SLSA - Generate & Verify Provenance"
    runs-on: ubuntu-latest
    needs: push-image
    permissions:
      id-token: write
      attestations: write
      packages: write
      contents: read
    steps:
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Attente que le manifest soit servi par GHCR (rare mais utile)
      - name: Wait for manifest availability
        run: |
          IMAGE="${{ needs.push-image.outputs.image_name }}@${{ needs.push-image.outputs.digest }}"
          for i in {1..10}; do
            if docker buildx imagetools inspect "$IMAGE" >/dev/null 2>&1; then
              echo "Manifest available"; exit 0
            fi
            echo "Waiting for $IMAGE (try $i/10)..."
            sleep 3
          done
          exit 1

      - name: Generate SLSA Provenance
        id: attest
        uses: actions/attest-build-provenance@v1
        with:
          subject-name: ${{ needs.push-image.outputs.image_name }}   # FQIN sans tag, normalis√©
          subject-digest: ${{ needs.push-image.outputs.digest }}     # sha256:...
          push-to-registry: true

      - name: Install slsa-verifier
        uses: slsa-framework/slsa-verifier/actions/installer@v2.7.1

      - name: Verify SLSA attestation (from GHCR)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          IMAGE="${{ needs.push-image.outputs.image_name }}@${{ needs.push-image.outputs.digest }}"
          slsa-verifier verify-image "$IMAGE" \
            --source-uri "github.com/${{ github.repository }}" \
            --print-provenance

  iac-scan:
    name: IaC Scan with Checkov
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    steps:
      - uses: actions/checkout@v4
      - name: Run Checkov
        uses: bridgecrewio/checkov-action@v12
        with:
          output_format: cli,sarif
          output_file_path: console,results.sarif
          exit-code: 0
          continue-on-error: true
        continue-on-error: true
      - name: Upload Checkov results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: success() || failure()
        with: { sarif_file: results.sarif }


# name: Complete Basic CI/CD Pipeline

# on:
#   push:
#     branches: [ main, develop ]
#   pull_request:
#     branches: [ main ]

# env:
#   REGISTRY: ghcr.io
#   IMAGE_NAME: ${{ github.repository }}

# jobs:


#   secret_scan:
#     name: TruffleHog Secret Scan
#     runs-on: ubuntu-latest
#     permissions:
#       contents: read
#       security-events: write
#     steps:
#     - name: Checkout repository
#       uses: actions/checkout@v4
#       with:
#         fetch-depth: 0
        
#     - name: Run TruffleHog to find secrets
#       uses: trufflesecurity/trufflehog@main
#       with:
#         path: ./

#   secret-scaning:
#     name: secret scanning with gitleaks
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@v4
#         with:
#           fetch-depth: 0

#       - uses: gitleaks/gitleaks-action@v2
#         with: 
#             exit-code: 0  
#         continue-on-error: true
#         env:
#           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

#   sast-scan:
#     name: Semgrep SAST Scan
#     runs-on: ubuntu-latest
#     permissions:
#       contents: read
#       security-events: write
#     container:
#       image: semgrep/semgrep

#     if: (github.actor != 'dependabot[bot]')

#     steps:
#       - name: Checkout repository
#         uses: actions/checkout@v4
        
#       - name: Run Semgrep Scan
#         run: semgrep scan --config auto --sarif --output semgrep.sarif || true

#       - name: Upload Semgrep SARIF to GitHub Security
#         uses: github/codeql-action/upload-sarif@v3
#         with:
#           sarif_file: semgrep.sarif

#   SCA-scan:
#     name: Run OSV Scanner for SCA
#     uses: "google/osv-scanner-action/.github/workflows/osv-scanner-reusable.yml@v2.2.2"
#     permissions:
#       actions: read
#       security-events: write
#       contents: read
#     with:
#       scan-args: |-
#         --recursive
#         ./
#       upload-sarif: true
#       fail-on-vuln: false


# # 1Ô∏è‚É£ JOB BUILD - Construction de l'image Docker
#   build-image:
#     name:  BUILD - Docker Image Construction
#     runs-on: ubuntu-latest
    
#     permissions:
#       contents: read
#       packages: write
#       actions: read
    
#     # Outputs pour les jobs suivants et SLSA
#     outputs:
#       image_name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
#       digest: ${{ steps.build.outputs.digest }}
#       image_uri: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
#       tags: ${{ steps.meta.outputs.tags }}
#       tags_json: ${{ steps.meta.outputs.json }}
      
#     steps:
#       # 1. R√©cup√©ration du code source
#       - name: Checkout repository
#         uses: actions/checkout@v4
      
#       # 2. Authentification au GitHub Container Registry
#       - name: Login to Container Registry
#         uses: docker/login-action@v3
#         with:
#           registry: ${{ env.REGISTRY }}
#           username: ${{ github.actor }}
#           password: ${{ secrets.GITHUB_TOKEN }}
      
#       # 3. Configuration des m√©tadonn√©es avec SHA prioritaire
#       - name: Extract metadata
#         id: meta
#         uses: docker/metadata-action@v5
#         with:
#           images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
#           tags: |
#             # SHA en priorit√© pour immutabilit√© et s√©curit√©
#             type=sha,prefix={{branch}}-,format=long,priority=1000
#             type=sha,prefix={{branch}}-,format=short,priority=900
#             # Tags traditionnels pour d√©veloppement
#             type=ref,event=branch,priority=600
#             type=ref,event=pr,priority=600
#             type=raw,value=latest,enable={{is_default_branch}},priority=200
#           labels: |
#             org.opencontainers.image.title=${{ github.repository }}
#             org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
#             org.opencontainers.image.revision=${{ github.sha }}
#             org.opencontainers.image.created={{date 'YYYY-MM-DDTHH:mm:ssZ'}}
#             # üîí Configuration pour image priv√©e
#             org.opencontainers.image.visibility=private
  
#       # 4. Build Docker image SEULEMENT (sans push)
#       - name: Build Docker image locally
#         id: build
#         uses: docker/build-push-action@v5
#         with:
#           context: .
#           push: false  # ‚úÖ Pas de push dans ce job
#           load: true   # ‚úÖ Charge l'image localement pour le scan suivant
#           tags: ${{ steps.meta.outputs.tags }}
#           labels: ${{ steps.meta.outputs.labels }}

#       - name: Generate SBOM with Syft
#         uses: anchore/sbom-action@v0
#         with:
#           image: ${{ steps.vars.outputs.first_tag }}  
#           format: spdx-json
#           artifact-name: sbom-${{ github.run_id }}.spdx.json
      

#       # 5. Sauvegarde de l'image pour le job suivant
#       - name: Save Docker image as artifact
#         run: |
#           echo "üíæ Sauvegarde de l'image pour le job de scan..."
#           # Sauvegarder la premi√®re tag comme r√©f√©rence
#           FIRST_TAG=$(echo '${{ steps.meta.outputs.tags }}' | head -n1)
#           docker save "$FIRST_TAG" | gzip > docker-image.tar.gz
#           echo "‚úÖ Image sauvegard√©e: docker-image.tar.gz"
      
#       - name: Upload image artifact
#         uses: actions/upload-artifact@v4
#         with:
#           name: docker-image-${{ github.run_id }}
#           path: docker-image.tar.gz
#           retention-days: 1
  
#       # 6. Affichage des informations de build
#       - name: Display build information
#         run: |
#           echo "üéâ === BUILD TERMIN√â AVEC SUCC√àS ==="
#           echo ""
#           echo "üì¶ Nom de l'image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
#           echo "üîë Digest (temporaire): ${{ steps.build.outputs.digest }}"
#           echo ""
#           echo "üè∑Ô∏è Tags pr√©par√©s:"
#           echo "${{ steps.meta.outputs.tags }}" | tr ',' '\n' | while read tag; do echo "  - $tag"; done
#           echo ""
#           echo "‚û°Ô∏è  Image pr√™te pour scan de s√©curit√©..."
  

#   # 2Ô∏è‚É£ JOB SCAN - Scanner de s√©curit√© des containers
#   container-scan:
#     name: üîç SCAN - Container Security Analysis  
#     runs-on: ubuntu-latest
#     needs: build-image
    
#     permissions:
#       contents: read
#       security-events: write
#       actions: read
    
#     # Outputs pour le job push
#     outputs:
#       scan_status: ${{ steps.scan-status.outputs.status }}
#       critical_count: ${{ steps.scan-status.outputs.critical }}
#       high_count: ${{ steps.scan-status.outputs.high }}
      
#     steps:
#       # 1. R√©cup√©ration du code (pour contexte)
#       - name: Checkout repository
#         uses: actions/checkout@v4
      
#       # 2. T√©l√©chargement de l'image construite
#       - name: Download image artifact
#         uses: actions/download-artifact@v4
#         with:
#           name: docker-image-${{ github.run_id }}
      
#       # 3. Chargement de l'image Docker
#       - name: Load Docker image
#         run: |
#           echo "üì• Chargement de l'image Docker..."
#           docker load < docker-image.tar.gz
#           echo "‚úÖ Image charg√©e avec succ√®s"
#           docker images
      
#       # 4. Scanner Trivy sur l'image
#       - name: Run Trivy vulnerability scanner
#         uses: aquasecurity/trivy-action@master
#         with:
#           image-ref: ${{ fromJSON(needs.build-image.outputs.tags_json).tags[0] }}
#           format: 'sarif'
#           output: 'trivy-results.sarif'
#           exit-code: 0  # Continue m√™me si vuln√©rabilit√©s
#           severity: 'CRITICAL,HIGH'
#         continue-on-error: true
      
#       # 5. Upload des r√©sultats vers GitHub Security
#       - name: Upload Trivy scan results to GitHub Security
#         uses: github/codeql-action/upload-sarif@v3
#         if: always()
#         with:
#           sarif_file: trivy-results.sarif
#         continue-on-error: true 
  
#       # 6. Analyse des r√©sultats et cr√©ation du statut
#       - name: Analyze scan results
#         id: scan-status
#         run: |
#           if [ -f trivy-results.sarif ]; then
#             CRITICAL_COUNT=$(jq '[.runs[0].results[] | select(.level == "error")] | length' trivy-results.sarif 2>/dev/null || echo "0")
#             HIGH_COUNT=$(jq '[.runs[0].results[] | select(.level == "warning")] | length' trivy-results.sarif 2>/dev/null || echo "0")
            
#             echo "üîç === R√âSULTATS DU SCAN DE S√âCURIT√â ==="
#             echo "Critical vulnerabilities: $CRITICAL_COUNT"
#             echo "High vulnerabilities: $HIGH_COUNT"
            
#             # Outputs pour le job suivant
#             echo "critical=$CRITICAL_COUNT" >> $GITHUB_OUTPUT
#             echo "high=$HIGH_COUNT" >> $GITHUB_OUTPUT
            
#             if [ "$CRITICAL_COUNT" -gt "0" ]; then
#               echo "status=critical_found" >> $GITHUB_OUTPUT
#               echo "‚ùå Critical vulnerabilities found! Review before production deployment."
#             else
#               echo "status=safe" >> $GITHUB_OUTPUT
#               echo "‚úÖ No critical vulnerabilities found."
#             fi
#           else
#             echo "status=scan_failed" >> $GITHUB_OUTPUT
#             echo "‚ö†Ô∏è No scan results file found."
#           fi
  
#   # 3Ô∏è‚É£ JOB PUSH - Publication de l'image Docker  
#   push-image:
#     name: üöÄ PUSH - Docker Image Publication
#     runs-on: ubuntu-latest
#     needs: [build-image, container-scan]
    
#     permissions:
#       contents: read
#       packages: write
#       actions: read
    
#     # Outputs finaux pour SLSA (reprend ceux du build)
#     outputs:
#       image_name: ${{ needs.build-image.outputs.image_name }}
#       digest: ${{ steps.push.outputs.digest }}  # Digest r√©el apr√®s push
#       image_uri: ${{ needs.build-image.outputs.image_name }}@${{ steps.push.outputs.digest }}
#       tags: ${{ needs.build-image.outputs.tags }}
      
#     steps:
#       # 1. R√©cup√©ration du code source
#       - name: Checkout repository
#         uses: actions/checkout@v4
      
#       # 2. Authentification au GitHub Container Registry
#       - name: Login to Container Registry
#         uses: docker/login-action@v3
#         with:
#           registry: ${{ env.REGISTRY }}
#           username: ${{ github.actor }}
#           password: ${{ secrets.GITHUB_TOKEN }}
      
#       # 3. Affichage du statut de scan
#       - name: Display security scan status
#         run: |
#           echo "üîç === STATUT DU SCAN DE S√âCURIT√â ==="
#           echo "Statut: ${{ needs.container-scan.outputs.scan_status }}"
#           echo "Vuln√©rabilit√©s critiques: ${{ needs.container-scan.outputs.critical_count }}"
#           echo "Vuln√©rabilit√©s √©lev√©es: ${{ needs.container-scan.outputs.high_count }}"
          
#           if [ "${{ needs.container-scan.outputs.scan_status }}" = "critical_found" ]; then
#             echo "‚ö†Ô∏è  Des vuln√©rabilit√©s critiques ont √©t√© trouv√©es!"
#             echo "üìã Consultez l'onglet Security > Code scanning pour les d√©tails"
#             # D√©commentez la ligne suivante pour bloquer le push si vuln√©rabilit√©s critiques
#             # exit 1
#           fi
      
#       # 4. Reconstruction et Push (n√©cessaire pour obtenir le vrai digest)
#       - name: Extract metadata (for push)
#         id: meta
#         uses: docker/metadata-action@v5
#         with:
#           images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
#           tags: |
#             type=sha,prefix={{branch}}-,format=long,priority=1000
#             type=sha,prefix={{branch}}-,format=short,priority=900
#             type=ref,event=branch,priority=600
#             type=ref,event=pr,priority=600
#             type=raw,value=latest,enable={{is_default_branch}},priority=200
#           labels: |
#             org.opencontainers.image.title=${{ github.repository }}
#             org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
#             org.opencontainers.image.revision=${{ github.sha }}
#             org.opencontainers.image.created={{date 'YYYY-MM-DDTHH:mm:ssZ'}}
#             org.opencontainers.image.visibility=private
      
#       # 5. Build final et Push pour obtenir le digest d√©finitif
#       - name: Build and push Docker image
#         id: push
#         uses: docker/build-push-action@v5
#         with:
#           context: .
#           push: true  # ‚úÖ Push final
#           tags: ${{ steps.meta.outputs.tags }}
#           labels: ${{ steps.meta.outputs.labels }}
  
#       # 6. Configuration de l'image comme priv√©e
#       - name: Set image visibility to private
#         run: |
#           echo "üîí Configuration de l'image comme priv√©e..."
#           echo "Image sera automatiquement configur√©e comme priv√©e"
      
#       # 7. Affichage des informations finales
#       - name: Display complete build information
#         run: |
#           echo "üéâ === PIPELINE TERMIN√â AVEC SUCC√àS ==="
#           echo ""
#           echo "üì¶ Nom de l'image: ${{ needs.build-image.outputs.image_name }}"
#           echo "üîë SHA Digest FINAL: ${{ steps.push.outputs.digest }}"
#           echo "üéØ URI compl√®te (immutable): ${{ needs.build-image.outputs.image_name }}@${{ steps.push.outputs.digest }}"
#           echo ""
#           echo "üè∑Ô∏è Tags disponibles:"
#           echo "${{ needs.build-image.outputs.tags }}" | tr ',' '\n' | while read tag; do echo "  - $tag"; done
#           echo ""
#           echo "üîí Visibilit√©: Image priv√©e (authentification requise)"
#           echo "‚ö° Recommandation: Utilisez le SHA digest pour la production"
#           echo ""
#           echo "üîç S√©curit√©: ${{ needs.container-scan.outputs.critical_count }} critical, ${{ needs.container-scan.outputs.high_count }} high vulnerabilities"
#           echo ""
#           echo "üìã Commandes utiles:"
#           echo "  - Pull: docker pull ${{ needs.build-image.outputs.image_name }}@${{ steps.push.outputs.digest }}"
#           echo "  - Inspect: docker inspect ${{ needs.build-image.outputs.image_name }}@${{ steps.push.outputs.digest }}"
#   attest:
#     name: Generate SLSA Provenance
#     needs: push-image # D√©pend du job de build et de push
#     runs-on: ubuntu-latest
#     permissions:
#       attestations: write # Requis pour enregistrer l'attestation
#       id-token: write      # Requis pour la signature sans cl√© via OIDC
#       contents: read
#       packages: read  
#     steps:
    
#       - name: Login to Container Registry
#         uses: docker/login-action@v3
#         with:
#           registry: ${{ env.REGISTRY }}
#           username: ${{ github.actor }}
#           password: ${{ secrets.GITHUB_TOKEN }}

#       - name: Verify image exists
#         run: |
#           echo "üîç V√©rification de l'existence de l'image..."
#           echo "Image: ${{ needs.push-image.outputs.image_name }}"
#           echo "Digest: ${{ needs.push-image.outputs.digest }}"
          
#           # V√©rifier le manifest
#           docker manifest inspect "${{ needs.push-image.outputs.image_name }}@${{ needs.push-image.outputs.digest }}" || {
#             echo "‚ùå Image non trouv√©e avec ce digest !"
#             echo "üìã Images disponibles :"
#             docker images --filter "reference=${{ needs.push-image.outputs.image_name }}"
#             exit 1
#           }
#           echo "‚úÖ Image trouv√©e et accessible"
      
#       # ‚úÖ NOUVEAU: Attendre que l'image soit compl√®tement disponible
#       - name: Wait for image availability
#         run: |
#           echo "‚è≥ Attente de la disponibilit√© compl√®te de l'image..."
#           for i in {1..30}; do
#             if docker manifest inspect "${{ needs.push-image.outputs.image_name }}@${{ needs.push-image.outputs.digest }}" >/dev/null 2>&1; then
#               echo "‚úÖ Image disponible apr√®s ${i} tentatives"
#               break
#             fi
#             echo "‚è≥ Tentative $i/30..."
#             sleep 10
#           done
        
#       - name: Generate SLSA Provenance
#         uses: actions/attest-build-provenance@v1
#         with:
#           subject-name: ${{ needs.push-image.outputs.image_name }}
#           subject-digest: ${{ needs.push-image.outputs.digest }}
#           push-to-registry: true


 
#   iac-scan:
#     name: IaC Scan with Checkov
#     runs-on: ubuntu-latest
#     permissions:
#       contents: read
#       security-events: write
#     steps:
#       - name: Checkout repository
#         uses: actions/checkout@v4

#       - name: Run Checkov
#         uses: bridgecrewio/checkov-action@v12
#         with:
#           output_format: cli,sarif
#           output_file_path: console,results.sarif
#           exit-code: 0  
#           continue-on-error: true
#         continue-on-error: true    # <-- Ajoutez cette ligne ici



#       - name: Envoyer les r√©sultats de Checkov √† GitHub Security
#         uses: github/codeql-action/upload-sarif@v3
#         if: success() || failure()
#         with:
#           sarif_file: results.sarif
#           exit-code: 0  
#           continue-on-error: true
